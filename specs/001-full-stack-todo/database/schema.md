# Database Specification: Schema

**Feature Branch**: `001-full-stack-todo`
**Created**: 2026-01-04
**Status**: Draft

## Purpose

This document specifies the database schema for the Full-Stack Todo Web Application. The schema defines the structure for storing user data and tasks using Neon PostgreSQL with SQLModel ORM.

## Database Technology

- **Database**: Neon Serverless PostgreSQL
- **ORM**: SQLModel
- **Connection**: Connection pooling and secure access

## Schema Design

### Tasks Table

**Purpose**: Stores user tasks with their details and status

**Fields**:
- `id` (integer, primary key, auto-increment)
  - Unique identifier for each task
  - Auto-generated by the database
- `user_id` (string, indexed)
  - Foreign key to the user who owns the task
  - Required for user isolation
  - Indexed for efficient queries
- `title` (string, required)
  - Title of the task
  - Maximum length: 255 characters
- `description` (text, optional)
  - Detailed description of the task
  - Can be null or empty
- `completed` (boolean, default: false)
  - Completion status of the task
  - Default value is false (incomplete)
- `created_at` (timestamp)
  - Timestamp when the task was created
  - Automatically set when record is created
- `updated_at` (timestamp)
  - Timestamp when the task was last updated
  - Automatically updated when record is modified

**Constraints**:
- `title` field is required (NOT NULL)
- `completed` field defaults to false
- `created_at` and `updated_at` are automatically managed
- `user_id` must reference a valid user (foreign key constraint)

**Indexes**:
- Primary key index on `id`
- Index on `user_id` for efficient user-based queries
- Composite index on (`user_id`, `completed`) for common filtering operations

### Users Table (Managed by Better Auth)

**Purpose**: Stores user authentication information
**Note**: This table is managed by the Better Auth system and is referenced by the Tasks table via the user_id foreign key.

## Relationships

### Task to User
- Each task belongs to exactly one user
- Foreign key relationship from `tasks.user_id` to `users.id`
- Enforces user isolation at the database level

## Data Integrity

### Constraints
- All tasks must have a valid user_id that references an existing user
- Task titles cannot be null
- User isolation is enforced by requiring all queries to filter by user_id

### Indexes
- Proper indexing ensures efficient queries, especially for user-specific data retrieval
- Indexes on user_id enable fast filtering of tasks by user

## Security Considerations

### User Isolation
- All database queries must be filtered by authenticated user ID
- Direct access to tasks of other users must be prevented at the database level
- URL user_id must match JWT user ID for validation

### Access Control
- Database access should be restricted to the backend application
- No direct database access from frontend
- All data access occurs via FastAPI backend

## Migration Strategy

### Initial Migration
1. Create the tasks table with all specified fields
2. Set up proper indexes for efficient querying
3. Establish foreign key relationship to users table (managed by Better Auth)
4. Set up automatic timestamp management

### Future Migrations
- Any schema changes must maintain backward compatibility
- Migration scripts must be versioned and tested
- Rollback procedures must be defined for each migration

## Performance Considerations

### Query Optimization
- Use indexed fields for filtering (especially user_id)
- Limit result sets where appropriate
- Use efficient query patterns for common operations

### Scalability
- Neon Serverless PostgreSQL provides automatic scaling
- Proper indexing supports performance as data grows
- Connection pooling manages database connections efficiently

## Constraints

- In-memory storage is forbidden - all data must be persisted to Neon PostgreSQL
- SQLModel must be used to define all schemas
- Each task must include user_id with ownership enforcement mandatory at query level
- No direct database access from frontend - all access via FastAPI
- User isolation must be enforced at the database query level